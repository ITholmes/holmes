# Kubernetes 的yaml配置文件

> Kubernetes 的 YAML 配置文件是定义和管理集群中的所有资源的关键工具。了解如何编写和使用这些配置文件对管理 Kubernetes 集群至关重要。



## 基础结构

Kubernetes YAML 配置文件通常由以下几个部分组成：

- `apiVersion`: 资源使用的 API 版本。
- `kind`: 资源的类型（如 Pod、Service、Deployment 等）。
- `metadata`: 元数据，例如名称和标签。
- `spec`: 资源的具体配置，如容器的配置、选择器、服务端口等。

例如：

```yaml
# nginx-deployment.yaml
apiVersion: apps/v1  # Kubernetes API 版本
kind: Deployment  # 资源类型
metadata:
  name: nginx-deployment  # 部署名称
  labels:
    app: nginx  # 标签，用于选择 Pod
spec:
  replicas: 3  # 副本数量
  selector:
    matchLabels:
      app: nginx  # 标签选择器，用于匹配 Pod
  template:
    metadata:
      labels:
        app: nginx  # Pod 的标签
    spec:
      containers:
      - name: nginx  # 容器名称
        image: nginx:latest  # 使用的镜像
        ports:
        - containerPort: 80  # 容器暴露的端口

---
# nginx-service.yaml
apiVersion: v1  # Kubernetes API 版本
kind: Service  # 资源类型
metadata:
  name: nginx-service  # 服务名称
spec:
  type: LoadBalancer  # 服务类型（LoadBalancer 将分配一个外部 IP）
  selector:
    app: nginx  # 标签选择器，用于选择服务后端的 Pods
  ports:
    - protocol: TCP  # 协议类型
      port: 80  # 服务暴露的端口
      targetPort: 80  # 目标端口（容器内部端口）
```

## kind 资源类型

| 资源类型                          | 用途（解释）                                                 |
| --------------------------------- | ------------------------------------------------------------ |
| Pod                               | Kubernetes 中的最小部署单元，包含一个或多个**容器**。        |
| Service                           | 为 Pod 提供稳定的**网络访问**抽象，支持负载均衡、服务发现等功能。 |
| Deployment                        | **管理 Pod 的声明性更新，支持滚动更新和回滚功能**。          |
| ConfigMap                         | **存储非机密的配置数据**，如环境变量、配置文件等。           |
| Secret                            | **存储敏感信息**，如密码、密钥等，避免将其暴露在 Pod 定义中。 |
| Namespace                         | 在同一 Kubernetes 集群中创建多个虚拟集群，实现资源**隔离**。 |
| PersistentVolume（PV）            | 定义一个存储卷，供 Pod 使用                                  |
| PersistentVolumeClaim（PVC）      | Pod 使用持久存储卷的请求，PVC 绑定到 PV                      |
| StatefulSet                       | 管理有状态应用，提供稳定的网络标识和持久存储。               |
| DaemonSet                         | 确保每个节点都运行一个 Pod 副本，常用于日志收集、监控等任务。 |
| Job                               | 创建一个一次性任务，直到成功完成。                           |
| CronJob                           | 定期执行任务，类似于 Linux 的 cron 作业。                    |
| Ingress                           | 管理外部访问服务的规则，通过 HTTP/HTTPS 提供服务。           |
| ServiceAccount                    | 为 Pod 提供与 Kubernetes API 交互的身份。                    |
| Role 和 ClusterRole               | 定义在命名空间或集群范围内的访问权限。                       |
| RoleBinding 和 ClusterRoleBinding | 将 Role 或 ClusterRole 绑定到用户或 ServiceAccount。         |
| HorizontalPodAutoscaler (HPA)     | 根据 CPU 或其他指标自动调整 Pod 的副本数量。                 |
| NetworkPolicy                     | 定义 Pod 之间以及 Pod 和外部之间的网络流量控制规则。         |
| ResourceQuota                     | 限制命名空间中资源的总使用量，例如 CPU、内存等。             |
| PodDisruptionBudget (PDB)         | 限制有多少个 Pod 可以同时被删除，用于维护时保证应用的高可用性。 |
| Volume                            | 定义一个存储卷，用于在 Pod 中共享数据或持久化存储。          |
| Endpoint                          | **存储一组 IP 地址，供 Service 使用**。                      |
| ReplicationController             | Kubernetes 中的一种**控制器**，用于**确保指定数量的 Pod 副本始终在运行**。 |

## metadata 元数据

通过案例分析 `metadata` ：

```yaml
apiVersion: v1
kind: Pod
metadata:
  # 资源的名称。在命名空间内必须唯一。
  name: example-pod
  
  # 资源所在的命名空间，用于组织和隔离资源。
  namespace: production
  
  # 标签，用于给资源打上标签，以便于组织、选择和过滤资源。
  labels:
    app: myapp        # 通过标签标识属于 `myapp` 应用的资源。
    environment: production  # 指定资源所处的环境为生产环境。
    tier: backend     # 指定资源属于后台服务。
  
  # 注解，用于存储附加的非标识性元数据。
  annotations:
    description: "This pod runs the backend service for my application."  # 关于 Pod 的描述信息。
    createdBy: "john.doe@example.com"  # 记录创建 Pod 的人员。
    version: "v1.0.0"  # 记录 Pod 的版本信息。
  
  # 拥有者引用，定义当前资源的拥有者关系。
  ownerReferences:
    - apiVersion: apps/v1  # 所属资源的 API 版本。
      kind: Deployment    # 所属资源的类型。
      name: example-deployment  # 所属资源的名称。
      uid: 12345678-abcd-1234-efgh-56789ijklmnop  # 所属资源的唯一标识符。
  
  # Finalizers，指定在删除资源之前需要执行的操作。
  finalizers:
    - example.com/my-finalizer  # 指定的 finalizer。
  
  # 当没有提供 `name` 时，Kubernetes 会基于这个前缀生成一个唯一名称。
  generateName: example-pod-
  
  # 资源的版本号，用于并发控制。(一般k8s自动生成，无需添加)
  resourceVersion: "456789"
  
  # 资源的唯一标识符，由 Kubernetes 自动分配。(一般k8s自动生成，无需添加)
  uid: 12345678-abcd-1234-efgh-56789ijklmnop
  
  # 资源创建的时间戳，通常由 Kubernetes 自动生成。(一般k8s自动生成，无需添加)
  creationTimestamp: "2024-08-13T00:00:00Z"
  
spec:
  containers:
  - name: my-container
    image: nginx:1.17
    ports:
    - containerPort: 80
```

## spec 资源规范（specification）

`spec` 定义了资源的具体配置和行为。

### deployment 类型

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: example-deployment
  namespace: default
  labels:
    app: myapp
spec:
  # 定义要运行的 Pod 副本数量。例如 3 表示运行三个 Pod 实例。
  replicas: 3
  
  # 选择器用于选择和管理 Pod，必须与 Pod 模板中的标签匹配。
  selector:
    matchLabels:
      app: myapp  # 匹配标签，用于选择和管理的 Pod。
  
  # Pod 模板定义了新创建的 Pod 的规范。
  template:
    metadata:
      labels:
        app: myapp  # 与 selector 中的标签匹配，用于标识 Pod。
    
    spec:
      # 定义 Pod 中运行的容器列表。
      containers:
      - name: my-container               # 容器的名称，在 Pod 内部必须唯一。
        image: nginx:1.17                # 容器使用的 Docker 镜像。
        ports:
        - containerPort: 80             # 容器监听的端口。
        env:
        - name: ENV_VAR
          value: "example-value"       # 环境变量，用于配置容器内的应用程序。
        resources:
          requests:
            memory: "64Mi"             # 容器启动时请求的内存量。
            cpu: "250m"                # 容器启动时请求的 CPU 核心数。
          limits:
            memory: "128Mi"            # 容器允许使用的最大内存量。
            cpu: "500m"                # 容器允许使用的最大 CPU 核心数。
        volumeMounts:
        - name: my-volume
          mountPath: /data             # 将卷挂载到容器中的路径。
      
      # 定义 Pod 使用的卷。
      volumes:
      - name: my-volume
        emptyDir: {}                   # 使用 `emptyDir` 卷类型，适用于存储临时数据。
      
      # 节点选择器，根据节点标签调度 Pod。
      nodeSelector:
        disktype: ssd                  # 选择带有 `disktype: ssd` 标签的节点。
      
      # Pod 亲和性，用于指定调度规则，使 Pod 被调度到满足特定条件的节点上。
      affinity:
        podAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - myapp
            topologyKey: "kubernetes.io/hostname"  # 指定 Pod 必须调度到相同主机上。
      
      # 容忍节点上的污点，允许 Pod 被调度到标记为特定污点的节点上。
      tolerations:
      - key: "key"
        operator: "Equal"
        value: "value"
        effect: "NoSchedule"          # 容忍 `NoSchedule` 类型的污点。
      
      # Pod 的重启策略。`Always` 表示 Pod 无论失败与否都会重新启动。
      restartPolicy: Always
        
      # 终止 Pod 时，给予容器的宽限时间，单位为秒。
      terminationGracePeriodSeconds: 30  # 在 Pod 终止前的宽限时间。
      
      # 指定 Pod 的优先级类，用于影响调度顺序和资源分配。
      priorityClassName: high-priority  # 优先级类名称。
      
      # 容器的安全上下文，指定容器的用户 ID 和文件系统组 ID。
      securityContext:
        runAsUser: 1000                  # 以特定用户身份运行容器。
        fsGroup: 2000                    # 容器中所有文件的组 ID。
      
      # 是否使用宿主机网络，`false` 表示使用集群网络。
      hostNetwork: false
        
      # DNS 策略，指定如何解析 DNS 名称，`ClusterFirst` 表示优先使用集群内的 DNS 解析服务。
      dnsPolicy: ClusterFirst
```

1. **`labels` 标签 和 `selector` 选择器的关联**：

- **选择器根据资源上的标签选择资源**。
- 选择器有多种类型，包括 `matchLabels` 和 `matchExpressions`。
- `matchLabels` 是最常用的选择器类型，使用简单的标签匹配。
- `matchExpressions` 提供了更复杂的匹配规则，比如支持多种操作符（`In`, `NotIn`, `Exists`, `DoesNotExist`）

```yaml
# 定义标签
metadata:
  labels:
    app: myapp
    
---
# 选择器
spec:
  selector:
    matchLabels:
      app: myapp 
```



2. **`volumes` 卷 和 `volumeMounts` 卷挂载 的关联** ：在 Kubernetes 中，`volumes` 定义了可以使用的存储卷，而 `volumeMounts` 指定这些卷挂载到容器的路径。

- **`volumes`**：定义了一个或多个卷，可以是宿主机目录（使用 `hostPath`），临时目录（使用 `emptyDir`），持久化存储卷，ConfigMap 等。
- **`volumeMounts`**：定义了如何将 `volumes` 中的卷挂载到 **容器** 的文件系统中。容器在 Pod 内运行，因此 `volumeMounts` 定义的是如何在这个隔离的容器环境中使用 `volumes`。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  containers:
  - name: my-container
    image: nginx
    volumeMounts:
    - name: host-volume
      mountPath: /container/path  # 容器内的挂载路径
  volumes:
  - name: host-volume
    hostPath:
      path: /host/path  # 宿主机上的路径
      type: Directory
```



3. **`affinity` 亲和** ：是一种调度策略，用于控制 Pod 如何选择节点进行调度。

- `nodeAffinity` 用于指定 Pod 应该调度到哪些节点上。它可以替代传统的 `nodeSelector`，提供更复杂的调度规则。

```yaml
affinity:
  nodeAffinity:
    # requiredDuringSchedulingIgnoredDuringExecution: 这是一个强制性的要求。Pod 只能调度到满足指定条件的节点上。
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: key-name
          operator: In
          values:
          - value1
          - value2
---
affinity:
  nodeAffinity:
  	# preferredDuringSchedulingIgnoredDuringExecution: 这是一个优选要求。它表示 Pod 应该尽量调度到满足条件的节点上，但不是强制性的。如果没有满足条件的节点，Pod 仍然可以调度到其他节点。
    preferredDuringSchedulingIgnoredDuringExecution:
    - preference:
        matchExpressions:
        - key: key-name
          operator: In
          values:
          - value1
      weight: 1
```

- `podAffinity` 和 `podAntiAffinity`：这两种类型的 `affinity` 用于控制 Pod 如何与其他 Pod 关系进行调度。

```yaml
affinity:
  # podAffinity 用于将 Pod 调度到与特定 Pod 位于同一节点或同一区域的节点上。 
  podAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      labelSelector:
        matchExpressions:
        - key: app
          operator: In
          values:
          - my-app
      topologyKey: kubernetes.io/hostname
---
affinity:
  # podAntiAffinity 用于将 Pod 调度到不与特定 Pod 位于同一节点或同一区域的节点上。
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      labelSelector:
        matchExpressions:
        - key: app
          operator: In
          values:
          - my-app
      topologyKey: kubernetes.io/hostname
```



4. **`Taints` 污点 和 ` Tolerations`  容忍的关联** ：

- **`Taints`**：节点上的 `taints` 是一种标记，用于指定节点上的某些条件或限制，阻止 Pod 调度到这些节点上，除非 Pod 具有相应的 `tolerations`。
- **`Tolerations`**：Pod 上的 `tolerations` 是一种允许 Pod 在具有特定 `taints` 的节点上调度的机制。它们“容忍”节点上的 `taints`，使 Pod 可以被调度到这些节点上。

```shell
# 配置 node-1 节点，添加污点
kubectl taint nodes center-node01 dedicated=infra:NoSchedule
# 移除污点（特定污点除外）
kubectl taint nodes center-node01 dedicated-

# 查看某个节点是否又污点
kubectl describe node center-node01
Name:               node-1
Roles:              <none>
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    failure-domain.beta.kubernetes.io/region=us-west-1
                    failure-domain.beta.kubernetes.io/zone=us-west-1a
                    kubernetes.io/hostname=node-1
                    node-role.kubernetes.io/worker=
Annotations:        node.alpha.kubernetes.io/ttl=0
                    scheduler.alpha.kubernetes.io/affinity: { "nodeAffinity": { "requiredDuringSchedulingIgnoredDuringExecution": { "nodeSelectorTerms": [ { "matchExpressions": [ { "key": "node.kubernetes.io/instance-type", "operator": "In", "values": [ "t2.micro" ] } ] } ] } } }
CreationTimestamp:  Fri, 13 Aug 2024 14:30:05 +0800
Taints:             dedicated=infra:NoSchedule
                    type=spot:NoExecute
...
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  # 配置 容忍
  tolerations:
  - key: dedicated
    operator: Equal
    value: infra
    effect: NoSchedule
  containers:
  - name: nginx
    image: nginx:latest
```

### service 类型

**`Service`**：提供了一种稳定的访问方式来路由流量到一组 Pod。`Service` 定义了如何访问这些 Pod，并可以提供负载均衡功能。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: example-service
  namespace: default
  labels:
    app: my-app
spec:
  selector:
    app: my-app                   # 选择标签为 app=my-app 的 Pod
  ports:
  - protocol: TCP
    port: 80                      # Service 对外暴露的端口
    targetPort: 8080              # 访问 Pod 时转发到 Pod 上的端口
    name: http                    # 端口名称（可选）
  type: ClusterIP                 # 服务类型
  sessionAffinity: None           # 会话亲和性（默认为 None）
#  loadBalancerIP: 192.168.1.100  # 负载均衡器 IP（可选，仅在 type 为 LoadBalancer 时有效）
```

**`Service` 的 DNS 名称：**

- **当你创建一个 `Service` 对象时，Kubernetes 会为其分配一个 DNS 名称，通常格式为 `<service-name>.<namespace>.svc.cluster.local`。**
- 例如，如果你有一个名为 `my-service` 的 `Service`，且它位于 `default` 命名空间，你可以通过 `my-service.default.svc.cluster.local` 来访问它。可以通过 `curl` 从一个Pod访问 `my-service`：

```shell
# 验证访问是否成功
curl http://my-service.default.svc.cluster.local
```

- 在 Kubernetes 集群中，虽然使用 **完全限定域名（FQDN，Fully Qualified Domain Name）**是一种标准做法，但在一些情况下，你也可以只使用 `Service` 名称或 `<service-name>.<namespace>`。
- **如果是处于同一命名空间可以去掉 `.svc.cluster.local`，直接通过  `service-name` 名称 或 `<service-name>.<namespace>` 实现**。

> Tips：通过这种方式，每个微服务通过配置对应的域名就可以去访问了。

![image-20240813163054379](https://raw.githubusercontent.com/xupengboo/xupengboo-picture/main/img/image-20240813163054379.png)

![image-20240813163904282](https://raw.githubusercontent.com/xupengboo/xupengboo-picture/main/img/image-20240813163904282.png)

### configmap 类型

configmap 就是定义添加一些配置内容：

```yaml
apiVersion: v1  # API 版本，ConfigMap 对象的 API 版本是 v1。
kind: ConfigMap  # 资源类型，这里是 ConfigMap。
metadata:
  name: example-configmap  # ConfigMap 的名称，用于唯一标识这个 ConfigMap。
  namespace: default  # ConfigMap 所在的命名空间。默认为 default。
  labels:
    app: my-app  # 标签，用于为 ConfigMap 打上标记，便于选择和管理。
data:
  # 配置文件的内容部分
  config.properties: |
    key1=value1  # 文件内容，以多行字符串形式存储。
    key2=value2
  application.yml: |
    server:
      port: 8080  # YAML 配置文件的内容，适用于复杂配置。
    logging:
      level: INFO
  mykey: myvalue  # 简单的键值对配置，直接存储值。
```

deployment类型 配置 configmap关联场景：

-  将 `ConfigMap` 挂载为卷
- 将 `ConfigMap` 数据作为环境变量
- 将 `ConfigMap` 数据作为命令行参数

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: example-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: example-app
  template:
    metadata:
      labels:
        app: example-app
    spec:
      containers:
      - name: example-container
        image: busybox
        command: ["/bin/sh"]
        args: ["-c", "echo $(MY_KEY)"] # 将 `ConfigMap` 数据作为命令行参数
        env:
        - name: MY_KEY
          valueFrom:
            configMapKeyRef:
              name: example-configmap # 将 `ConfigMap` 数据作为环境变量
              key: mykey
```

### endpoint 类型

**一般 `Endpoints` 与 `Service` 是相互配合**：

- **`Service`**:  `Service` 是一个抽象层，它提供了一个稳定的 IP 地址和端口，通过负载均衡将流量分发到匹配的 Pod 上。`Service` 会自动创建和更新 `Endpoints` 对象，以确保流量路由到正确的 Pod。
- **`Endpoints`**:  `Endpoints` 对象存储 `Service` 的实际后端 Pod 的 IP 地址和端口。它被自动管理和更新，以匹配 `Service` 选择的 Pod。

一句话来说就是：**`Service` 对象通过 `Endpoints` 对象来映射到实际的 Pod。`Endpoints` 存储 `Service` 的实际后端 Pod 的 IP 地址和端口。**

```yaml
apiVersion: v1
kind: Endpoints
metadata:
  name: example-endpoints  # Endpoints 对象的名称，用于标识该对象
  namespace: default       # Endpoints 所在的命名空间，与 Service 对象的命名空间相匹配
subsets:
- addresses:
  - ip: 10.0.0.1           # Pod 的 IP 地址
    hostname: pod1         # Pod 的主机名（可选）
    targetRef:
      kind: Pod            # 目标对象的类型，这里是 Pod
      name: example-pod    # Pod 的名称
      namespace: default   # Pod 所在的命名空间
  ports:
  - port: 80               # Pod 上的端口，Service 将流量路由到这个端口
    protocol: TCP          # 使用的协议，这里是 TCP
    name: http             # 端口的名称（可选），用于标识端口
```

